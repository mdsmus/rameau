
Estranhamente, ordenar os segmentos antes de passá-los para a árvore
de decisão não afeta a performance. O seguinte patch mostra isso:

From e9bb0d9393642fe2576ae1d415aaf1d07fc64017 Mon Sep 17 00:00:00 2001
From: Alexandre Passos <alexandre.tp@gmail.com>
Date: Sun, 20 Jan 2008 12:37:16 -0300
Subject: [PATCH] =?utf-8?q?Ordenar=20arvores=20de=20decis=C3=A3o?=
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit

---
 src/algoritmos/tree.lisp |    7 +++++--
 1 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/algoritmos/tree.lisp b/src/algoritmos/tree.lisp
index e75400e..07ae929 100644
--- a/src/algoritmos/tree.lisp
+++ b/src/algoritmos/tree.lisp
@@ -27,8 +27,11 @@
 
 (defparameter *nomes* '(pitch1 pitch2 pitch3 pitch4))
 
+(defun ordena-segmento (segmento)
+  (sort (copy-list segmento) #'< :key #'evento-pitch ))
+
 (defun prepara-segmento (segmento)
-  (loop for nota in segmento
+  (loop for nota in (ordena-segmento segmento)
      for n in *nomes* collect (cons n (evento-pitch nota))))
 
 (defun prepara-exemplo-treinamento (coral gabarito)
@@ -105,7 +108,7 @@
 
 
 (defun prepara-context-segmento (segmentos)
- (loop for notas =  (reduce #'append segmentos) then (cdr notas)
+ (loop for notas =  (reduce #'append segmentos :key #'ordena-segmento) then (cdr notas)
     for nota = (aif (first notas) it nota)
     for n in *context-nomes* collect (cons n (if nota (evento-pitch nota) nil))))
 
-- 
1.5.3.4


