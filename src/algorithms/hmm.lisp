(defpackage :rameau-hmm
  (:import-from #:arnesi "AIF" "IT" "LAST1" "ENABLE-SHARP-L-SYNTAX" "AWHEN")
  (:shadowing-import-from #:rameau-base #:defun #:defmacro #:defparameter #:defvar #:defstruct)
  (:use #:cl #:rameau #:genoslib #:rameau-options #:iterate #:vecto))

(in-package :rameau-hmm)

(enable-sharp-l-syntax)

;;; Implementação de um algoritmo para análise harmônica automática
;;; usando modelos de Markov escondidos. A descrição do modelo usado
;;; está em docs/hmm.tex.

(defclass hmm (rameau-algorithm)
  ((transitions :accessor trans :initform nil)
   (initial-transitions :accessor start-trans :initform nil)
   (chord-notes :accessor notes :initform nil)))

(defparameter *chords*
  (iter (for root from 0 to 95)
        (appending (iter (for mode in '("" "m" "+" "°" "ø" "!"))
                         (appending (iter (for seventh in '("" "7" "7-" "7+"))
                                          (collect (make-chord :root (print-note (code->notename root) 'latin)
                                                               :mode mode
                                                               :7th seventh))))))))

(defparameter *nct* (list (make-melodic-note)))
(defparameter *aug6s* (iter (for type in '("al" "fr" "it"))
                            (collect (make-augmented-sixth :type type))))

(defparameter *labels* (append *chords* *nct* *aug6s*))
(defparameter *nlabels* (length *labels*))

(defun label->list (label)
  (cond ((chord-p label)
         (list :chord (make-keyword (chord-mode label)) (make-keyword (chord-root label)) (make-keyword (chord-7th label))))
        ((melodic-note-p label)
         (list :melodic-note))
        ((augmented-sixth-p label)
         (list :augmented-sixth (augmented-sixth-type label)))
        (t (list :other))))

(defparameter *llabels* (mapcar #'label->list *labels*))
         
(defun label->number (label)
  (or (position (label->list label) *llabels* :test #'equal)
      (error "Should never be nil")))

(defun number->label (number)
  (nth number *labels*))

(defun transpose-96 (data)
  (destructuring-bind (coral gabarito) data
    (iter (for i from 0 to 95)
          (collect (list (transpose-segmentos coral i)
                         (transpose-chords gabarito i))))))

(defun collect-pairs (data)
  (iter (for (chorale answer) in data)
        (nconcing (iter (for c in chorale)
                        (for a in answer)
                        (collect (list c a))))))

(defun estimate-transitions (chords)
  (let ((chords (mapcar #'label->number (mapcan #'identity chords)))
        (transitions (make-array (list *nlabels* *nlabels*) :initial-element 1.0d0 :element-type 'double-float)))
    (iter (for c in chords)
          (for p previous c)
          (when (and p c)
            (incf (aref transitions p c))
            ))
    (iter (for c from 0 below *nlabels*)
          (let ((sum (iter (for j from 0 below *nlabels*) (sum (aref transitions c j)))))
            (iter (for j from 0 below *nlabels*)
                  (setf (aref transitions c j) (log (/ (aref transitions c j) sum)))
                  )))
    transitions))

(defun estimate-chord-probabilities (chords)
  (let ((chords (mapcar #'label->number chords))
        (probs (make-array (list *nlabels*) :initial-element 1d0 :element-type 'double-float)))
    (iter (for c in chords)
          (incf (aref probs c)))
    (let ((sum (iter (for c from 0 below *nlabels*) (sum (aref probs c)))))
      (iter (for c from 0 below *nlabels*)
            (setf (aref probs c) (log (/ (aref probs c) sum)))))
    probs))

(defun estimate-chord-notes (pairs)
  (let ((pairs (mapcar #L(list (label->number (second !1)) (mapcar #'event-pitch (first !1)))
                       pairs))
        (probs (make-array (list *nlabels* 96) :initial-element 1d0 :element-type 'double-float)))
    (iter (for (label notes) in pairs)
          (iter (for n in notes)
                (incf (aref probs label n))))
    (iter (for i from 0 below *nlabels*)
          (let ((sum (iter (for j from 0 below 96) (sum (aref probs i j)))))
            (iter (for j from 0 below 96)
                  (setf (aref probs i j) (log (/ (aref probs i j) sum))))))
    probs))

(defun train-hmm (alg)
  (let* ((training-data (mapcan #'transpose-96 *training-data*))
         (chords (mapcar #'second training-data))
         (pairs (collect-pairs training-data)))
    (setf (trans alg) (estimate-transitions chords)
          ;(start-trans alg) (estimate-chord-probabilities chords)
          (notes alg) (estimate-chord-notes pairs))))

(defun normalize (zero one min max value)
  (let ((value (- value min))
        (max (- max min)))
    (+ zero
       (* one (/ value max)))))

(defun output-note-images (alg)
  ;; chord-notes
  (let ((notes (notes alg)))
    (with-canvas (:width  800 :height 1050)
      (let ((font (get-font (rameau-get-font-path "Vera.ttf"))))
        (rectangle 0 0 800 1050)
        (set-rgb-stroke 0 0 0)
        (fill-path)
        (set-rgb-stroke 1 1 1)
        (set-font font 10)
        (dbg :hmm-prof "Putting the notenames~%")
        (iter (for i from 0 to 95)
              (string-paths 5 (+ 5 (* i 10)) (print-note (code->notename i)))
              (stroke))
        (dbg :hmm-prof "Putting the chords~%")
        (iter (for i from 0)
              (for chord in (last *labels* 20))
              (string-paths (+ 60 (* 30 i)) 1000 (format nil "~a" chord))
              (stroke))
        (stroke)
        (set-rgb-stroke 1 0 0)
        (set-rgb-fill 1 0 0)
        (set-line-width 10)
        (dbg :hmm-prof "Counting the colors~%")
        (let ((max most-negative-double-float)
              (min most-positive-double-float))
          (iter (for i from 0 below *nlabels*)
                (iter (for j from 0 below 96)
                      (when (< max (aref notes i j))
                        (setf max (aref notes i j)))
                      (when (> min (aref notes i j))
                        (setf min (aref notes i j)))))
          (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%"
                  min max)
          (iter (for i from (- *nlabels* 20) below *nlabels*)
                (for n from 0 to 20)
                (iter (for j from 0 below 96)
                      (when (< (* 100 min) (aref notes i j))
                        (centered-circle-path (+ 70 (* 30 n))
                                              (+ 7 (* 10 j))
                                              (normalize 0 4 min max (aref notes i j))))
                      (fill-path))
                (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*)))
        (save-png (concat *rameau-path* "docs/view-hmm-note-probabilities.png"))))))

(defun output-transition-images (alg)
  (let ((tr (trans alg)))
    (with-canvas (:width  8000 :height 500)
      (let ((font (get-font "/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf")))
        (rectangle 0 0 10000 600)
        (set-rgb-stroke 0 0 0)
        (fill-path)
        (set-rgb-stroke 1 1 1)
        (set-font font 10)
        (dbg :hmm-prof "Putting the input labels~%")
        (iter (for i from 0)
              (for c in (last *labels* 40))
              (string-paths 0 (+ 5 (* i 10)) (format nil "~a" c))
              (stroke))
        (dbg :hmm-prof "Putting the output labels~%")
        (iter (for i from 0)
              (for c in *labels*)
              (string-paths (+ 40 (* 3 i)) (+ 410 (mod (* 10 i) 100)) (format nil "~a" c))
              (stroke))
        (dbg :hmm-prof "Finding the minimal and maximal weights~%")
        (set-rgb-fill 1 0 0)
        (let ((max most-negative-double-float)
              (min most-positive-double-float))
          (iter (for i from (- *nlabels* 40) below *nlabels*)
                (iter (for j from 0 below *nlabels*)
                      (when (< max (aref tr i j))
                        (setf max (aref tr i j)))
                      (when (> min (aref tr i j))
                        (setf min (aref tr i j)))))
          (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%"
                  min max)
          (iter (for i from (- *nlabels* 40) below *nlabels*)
                (for n from 0 to 40)
                (iter (for j from 0 below *nlabels*)
                      (centered-circle-path (+ 40 (* 3 j))
                                            (+ 7 (* 10 n))
                                            (normalize 0 4 min max (aref tr i j)))
                      (fill-path))
                (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*)))
        (save-png (concat *rameau-path* "docs/view-hmm-trans-probabilities.png"))))))
        
;; (setf my-hmm (last1 rameau:*algorithms*))
;;(output-transition-images my-hmm)
;; (train-hmm my-hmm)


(defmethod do-options ((alg hmm) options)
  (when (aget :visualize (arg :options options))
    (output-note-images alg)
    (output-transition-images alg))
  (when (aget :train (arg :options options))
    (train-hmm alg)))

(defun notes-probabilities (segment notes chord)
  (let ((pitches (mapcar #'event-pitch segment)))
    (iter (for p in pitches)
          (sum (aref notes chord p)))))

(defun viterbi-decode (segments alg)
  (let* ((tran (trans alg))
         ;(ini (start-trans alg))
         (notes (notes alg))
         (size (length segments))
         (tp (make-array (list size *nlabels*) :element-type 'double-float))
         (m (make-array (list size *nlabels*) :element-type 'integer)))
    (dbg :hmm-prof "Setting up initial conditions...~%")
    (iter (for j from 0 below *nlabels*)
          (setf (aref tp 0 j) (notes-probabilities (first segments) notes j)))
    (dbg :hmm-prof " ... done.~%")
    (iter (for i from 1 below size)
          (for seg in (cdr segments))
          (dbg :hmm-prof "  Analysing sonority ~a~%" i)
          (iter (for j from 0 below *nlabels*)
                (let ((maxjp 0)
                      (maxp most-negative-double-float)
                      (np (notes-probabilities seg notes j)))
                  (iter (for jp from 0 below *nlabels*)
                        (let ((p (+ (aref tp (1- i) jp)
                                    (aref tran jp j)
                                    np)))
                          (when (> p maxp)
                            (setf maxp p
                                  maxjp jp))))
                  (setf (aref tp i j) maxp)
                  (setf (aref m i j) maxjp))))
    (dbg :hmm-prof "Backtracking...~%")
    (let ((chords (let ((maxp most-negative-double-float)
                        (maxj 0)
                        (i (1- size)))
                    (iter (for j from 0 below *nlabels*)
                          (when (> (aref tp i j) maxp)
                            (setf maxp (aref tp i j)
                                  maxj j)))
                    (list maxj)))
          j)
      (setf j (first chords))
      (iter (for i from (1- size) downto 1)
            (push (aref m i j) chords)
            (setf j (aref m i j)))
      (mapcar #'number->label chords))))

(defmethod perform-analysis (segments options (alg hmm))
  (declare (ignore options))
  (let ((result (add-inversions segments (viterbi-decode segments alg))))
    (dbg :hmm-prof "Done...~%")
    result))

(add-algorithm (make-instance 'hmm
                              :name "EC-Hmm"
                              :description "A Hidden Markov Model for chord labeling."))

(defclass hmm-bayes (hmm) ())

(defun train-hmm-bayes (alg)
  (let* ((training-data (mapcan #'transpose-96 *training-data*))
         (pairs (collect-pairs training-data)))
    (setf (notes alg) (estimate-chord-notes pairs))))

(defmethod do-options ((alg hmm-bayes) options)
  (when (aget :visualize (arg :options options))
    (output-note-images alg))
  (when (aget :train (arg :options options))
    (train-hmm-bayes alg)))

(defun bayes-decode (segments alg)
  (let ((notes (notes alg)))
    (iter (for s in segments)
          (for n from 0)
          (dbg :hmm-prof " Bayes-Analyzing sonority ~a~%" n)
          (let (max
                (maxp most-negative-double-float))
            (iter (for i from 0 below *nlabels*)
                  (let ((atual (notes-probabilities s notes i)))
                    (when (< maxp atual)
                      (setf maxp atual
                            max i))))
            (collect (number->label max))))))

(defmethod perform-analysis (segments options (alg hmm-bayes))
  (declare (ignore options))
  (add-inversions segments (bayes-decode segments alg)))

(add-algorithm (make-instance 'hmm-bayes
                              :name "ES-Bay"
                              :description "A naive bayes classifier for chord labeling."))