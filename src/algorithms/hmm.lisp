(defpackage :rameau-hmm
  (:import-from #:arnesi "AIF" "IT" "LAST1" "ENABLE-SHARP-L-SYNTAX" "AWHEN")
  (:shadowing-import-from #:rameau-base #:defun #:defmacro #:defparameter #:defvar #:defstruct)
  (:use #:cl #:rameau #:genoslib #:rameau-options #:iterate #:vecto))

(in-package :rameau-hmm)

(enable-sharp-l-syntax)

;;; Implementação de um algoritmo para análise harmônica automática
;;; usando modelos de Markov escondidos. A descrição do modelo usado
;;; está em docs/hmm.tex.

(defclass hmm (rameau-algorithm)
  ((transitions :accessor trans :initform nil)
   (special-transitions :accessor special-trans :initform nil)
   (initial-transitions :accessor start-trans :initform nil)
   (chord-notes :accessor notes :initform nil)
   (special-notes :accessor special-notes :initform nil)))

(defparameter *chords*
  (iter (for root from 0 to 95)
        (appending (iter (for mode in '("" "m" "+" "°" "ø" "!"))
                         (appending (iter (for seventh in '("" "7" "7-" "7+"))
                                          (collect (make-chord :root (print-note (code->notename root) 'latin)
                                                               :mode mode
                                                               :7th seventh))))))))

(defparameter *modes*
  (iter (for mode in '("" "m" "+" "°" "ø" "!"))
        (appending (iter (for seventh in '("" "7" "7-" "7+"))
                         (collect (make-chord :root "C"
                                              :mode mode
                                              :7th seventh))))))

(defparameter *nct* (list (make-melodic-note)))
(defparameter *aug6s* (iter (for type in '("al" "fr" "it"))
                            (collect (make-augmented-sixth :type type))))

(defparameter *specials* (append *nct* *aug6s*))

(defparameter *labels* (append *chords* *nct* *aug6s*))
(defparameter *nlabels* (length *labels*))
(defparameter *nchords* (length *chords*))
(defparameter *nmodes* (length *modes*))
(defparameter *nspecials* (length *specials*))

(defun mode->list (mode)
  (list :chord (make-keyword (chord-mode mode)) (make-keyword (chord-7th mode))))

(defparameter *lmodes* (mapcar #'mode->list *modes*))

(defun mode->number (mode)
  (position (mode->list mode) *lmodes* :test #'equal))

(defun number->mode (number)
  (nth number *modes*))

(defun label->list (label)
  (cond ((chord-p label)
         (list :chord (make-keyword (chord-mode label)) (make-keyword (chord-root label)) (make-keyword (chord-7th label))))
        ((melodic-note-p label)
         (list :melodic-note))
        ((augmented-sixth-p label)
         (list :augmented-sixth (make-keyword (augmented-sixth-type label))))
        ((null label)
         (error "Should not be nil"))
        ((listp label)
         (label->list (first label)))
        (t (list :other))))

(defparameter *llabels* (mapcar #'label->list *labels*))
(defparameter *lspecials* (mapcar #'label->list *specials*))

(defun label->number (label)
  (or (position (label->list label) *llabels* :test #'equal)
      (error "Should never be nil")))

(defun number->label (number)
  (nth number *labels*))

(defun special->number (label)
  (or (position (label->list label) *lspecials* :test #'equal)
      (error "Should never be nil")))

(defun number->special (number)
  (nth number *specials*))

(defun transpose-96 (data)
  (destructuring-bind (coral gabarito) data
    (iter (for i from 0 to 95)
          (collect (list (transpose-segmentos coral i)
                         (transpose-chords gabarito i))))))

(defun collect-pairs (data)
  (iter (for (chorale answer) in data)
        (nconcing (iter (for c in chorale)
                        (for a in answer)
                        (collect (list c a))))))

(defun reroot (prev chord)
  (if (chord-p chord)
      (make-chord :root (print-note (code->notename (module (- (parse-note (chord-root chord))
                                                               (parse-note (chord-root prev))))))
                  :mode (chord-mode chord)
                  :7th (chord-7th chord))
      (if (listp chord)
          (make-melodic-note)
          chord)))

(defun not-zero (value not-zero)
  (if (= 0 value)
      not-zero
      value))

(defun dirichlett-smooth (array sizea sizeb)
  (iter (for i from 0 below sizea)
        (let ((sum (iter (for j from 0 below sizeb) (sum (aref array (+ (* sizeb i) j)))))
              (zeros (iter (for j from 0 below sizeb) (counting (= 0 (aref array (+ (* sizeb i) j)))))))
          (iter (for j from 0 below sizeb)
                (setf (aref array (+ (* sizeb i) j))
                      (log (/ (not-zero (aref array (+ (* sizeb i) j)) (/ 1 (+ 0.00000001 zeros))) (1+ sum))))))))

(defun estimate-transitions (chords)
  (let ((transitions (make-array (* *nmodes* *nlabels*) :initial-element 0d0 :element-type 'double-float)))
    (iter (for c in chords)
          (for p previous c)
          (when (and p c (chord-p p))
            (incf (aref transitions (+ (* *nlabels* (mode->number p)) (label->number (reroot p c)))))))
    (dirichlett-smooth transitions *nmodes* *nlabels*)
    transitions))

(defun estimate-special-transitions (chords)
  (let ((transitions (make-array (* *nmodes* *nlabels*) :initial-element 0d0 :element-type 'double-float)))
    (iter (for c in chords)
          (for p previous c)
          (when (and p c (not (chord-p p)) (not (listp p)))
            (incf (aref transitions (+ (* *nlabels* (special->number p)) (label->number c))))))
    (dirichlett-smooth transitions *nmodes* *nlabels*)
    transitions))

(defun estimate-chord-notes (pairs)
  (let ((pairs (mapcar #L(and (chord-p (second !1))
                              (list (mode->number (second !1)) (mapcar #'event-pitch (first !1)) (parse-note (chord-root (second !1)))))
                       pairs))
        (probs (make-array (list (* *nmodes* 96)) :initial-element 0d0 :element-type 'double-float)))
    (iter (for (label notes root) in pairs)
          (and label notes root
               (iter (for n in notes)
                     (incf (aref probs (+ (* 96 label) (module (- n root))))))))
    (dirichlett-smooth probs *nmodes* 96)
    probs))

(defun get-special (l)
  (if (listp l)
      (iter (for i in l)
            (unless (chord-p i)
              (return i)))
      l))

(defun estimate-special-notes (pairs)
  (let ((pairs (mapcar #L(and (not (listp (second !1)))
                              (not (chord-p (second !1)))
                              (list (special->number (get-special (second !1))) (mapcar #'event-pitch (first !1))))
                       pairs))
        (probs (make-array (list (* *nspecials* 96)) :initial-element 0d0 :element-type 'double-float)))
    (iter (for (label notes) in pairs)
          (and label notes
               (iter (for n in notes)
                     (incf (aref probs (+ (* 96 label) n))))))
    (dirichlett-smooth probs *nspecials* 96)
    probs))

(defun estimate-start-trans (chords)
  (let ((start (make-array *nlabels* :element-type 'double-float :initial-element 0d0)))
    (iter (for c in chords)
          (if (listp c)
            (iter (for cc in c)
                  (incf (aref start (label->number cc))))
            (incf (aref start (label->number c)))))
    (dirichlett-smooth start 1 *nlabels*)
    start))

(defun train-hmm (alg)
  (let* ((chords (reduce #'append (mapcar #'second *training-data*)))
         (pairs (collect-pairs *training-data*)))
    (setf (trans alg) (estimate-transitions chords)
          (special-trans alg) (estimate-special-transitions chords)
          (special-notes alg) (estimate-special-notes pairs)
          (start-trans alg) (estimate-start-trans chords)
          (notes alg) (estimate-chord-notes pairs))))

(defun normalize (zero one min max value)
  (let ((value (- value min))
        (max (- max min)))
    (+ zero
       (* one (/ value max)))))

(defun output-note-images (alg)
  ;; chord-notes
  (let ((notes (notes alg))
        (specials (special-notes alg)))
    (with-canvas (:width  900 :height 1050)
      (let ((font (get-font (rameau-get-font-path "Vera.ttf"))))
        (rectangle 0 0 900 1050)
        (set-rgb-stroke 0 0 0)
        (fill-path)
        (set-rgb-stroke 1 1 1)
        (set-font font 10)
        (dbg :hmm-prof "Putting the notenames~%")
        (iter (for i from 0 to 95)
              (string-paths 5 (+ 5 (* i 10)) (print-note (code->notename i)))
              (stroke))
        (dbg :hmm-prof "Putting the chords~%")
        (iter (for i from 0)
              (for chord in *modes*)
              (string-paths (+ 60 (* 30 i)) 1000 (format nil "~s" chord))
              (stroke))
        (iter (for i from *nmodes*)
              (for chord in *specials*)
              (string-paths (+ 60 (* 30 i)) 1000 (format nil "~s" chord))
              (stroke))
        (set-rgb-stroke 1 0 0)
        (set-rgb-fill 1 0 0)
        (set-line-width 10)
        (dbg :hmm-prof "Counting the colors~%")
        (let ((max most-negative-double-float)
              (min most-positive-double-float))
          (iter (for i from 0 below *nmodes*)
                (iter (for j from 0 below 96)
                      (when (< max (aref notes (+ (* 96 i) j)))
                        (setf max (aref notes (+ (* 96 i) j))))
                      (when (> min (aref notes (+ (* 96 i) j)))
                        (setf min (aref notes (+ (* 96 i) j))))))
          (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%"
                  min max)
          (iter (for i from 0 below *nmodes*)
                (for n from 0)
                (iter (for j from 0 below 96)
                      (centered-circle-path (+ 70 (* 30 n))
                                            (+ 7 (* 10 j))
                                            (normalize 0 4 min max (aref notes (+ (* 96 i) j))))
                      (fill-path))
                (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*))
          (dbg :hmm-prof "Now the special chords.~%")
          (iter (for i from (- *nlabels* *nspecials*) below *nlabels*)
                (for n from 0)
                (for m from *nmodes*)
                (iter (for j from 0 below 96)
                      (centered-circle-path (+ 70 (* 30 m))
                                            (+ 7 (* 10 j))
                                            (normalize 0 4 min max (aref specials (+ (* 96 n) j))))
                      (fill-path))
                (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*)))
        (save-png (concat *rameau-path* "docs/view-hmm-note-probabilities.png"))))))

(defun output-transition-images (alg)
  (let ((tr (trans alg))
        (str (special-trans alg)))
    (with-canvas (:width  8000 :height 500)
      (let ((font (get-font "/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf")))
        (rectangle 0 0 10000 600)
        (set-rgb-stroke 0 0 0)
        (fill-path)
        (set-rgb-stroke 1 1 1)
        (set-font font 10)
        (dbg :hmm-prof "Putting the input labels~%")
        (iter (for i from 0)
              (for c in *modes*)
              (string-paths 0 (+ 5 (* i 10)) (format nil "~a" c))
              (stroke))
        (iter (for i from *nmodes*)
              (for c in *specials*)
              (string-paths 0 (+ 5 (* i 10)) (format nil "~a" c))
              (stroke))
        (dbg :hmm-prof "Putting the output labels~%")
        (iter (for i from 0)
              (for c in *labels*)
              (string-paths (+ 40 (* 3 i)) (+ 410 (mod (* 10 i) 100)) (format nil "~a" c))
              (stroke))
        (dbg :hmm-prof "Finding the minimal and maximal weights~%")
        (set-rgb-fill 1 0 0)
        (let ((max most-negative-double-float)
              (min most-positive-double-float))
          (iter (for i from 0 below *nmodes*)
                (iter (for j from 0 below *nlabels*)
                      (when (< max (aref tr (+ (* *nlabels* i) j)))
                        (setf max (aref tr (+ (* *nlabels* i) j))))
                      (when (> min (aref tr (+ (* *nlabels* i) j)))
                        (setf min (aref tr (+ (* *nlabels* i) j))))))
          (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%"
                  min max)
          (iter (for i from 0 below *nmodes*)
                (iter (for j from 0 below *nlabels*)
                      (centered-circle-path (+ 40 (* 3 j))
                                            (+ 7 (* 10 i))
                                            (normalize 0 4 min max (aref tr (+ (* *nlabels* i) j))))
                      (fill-path))
                (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*))
          (iter (for n from *nmodes* below (+ *nmodes* *nspecials*))
                (for i from 0)
                (iter (for j from 0 below *nlabels*)
                      (centered-circle-path (+ 40 (* 3 j))
                                            (+ 7 (* 10 n))
                                            (normalize 0 4 min max (aref str (+ (* *nlabels* i) j))))
                      (fill-path))
                (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*)))
        (save-png (concat *rameau-path* "docs/view-hmm-trans-probabilities.png"))))))
        
;; (setf my-hmm (last1 rameau:*algorithms*))
;;(output-transition-images my-hmm)
;; (train-hmm my-hmm)


(defmethod do-options ((alg hmm) options)
  (when (aget :visualize (arg :options options))
    (output-note-images alg)
    (output-transition-images alg))
  (when (aget :train (arg :options options))
    (train-hmm alg)))

(defun notes-probabilities (segment notes i j)
  (let ((pitches (mapcar #'event-pitch segment)))
    (iter (for p in pitches)
          (sum (aref notes (+ (* 96 i) (module (- p j))))))))

(defun special-probabilities (segment specials special)
  (let ((pitches (mapcar #'event-pitch segment)))
    (iter (for p in pitches)
          (sum (aref specials (+ (* 96 special) p))))))

(defparameter *maxmodes* (* 96 *nmodes*))

(defun probabilities (seg notes specials j)
  (if (< j *maxmodes*)
      (notes-probabilities seg notes (mod j *nmodes*) (truncate j *nmodes*))
      (special-probabilities seg specials (- j *maxmodes*))))

(defun get-tran (tr str p c)
  (if (< p *maxmodes*)
      (aref tr (+ (* *nlabels* (mod p *nmodes*))
                  (mod (- c (truncate p *nmodes*))
                       *nlabels*)))
      (aref str (+ (* *nlabels* (- p *maxmodes*))
                   c))))

(defun viterbi-decode (segments alg)
  (let* ((tran (trans alg))
         (strans (special-trans  alg))
         ;(ini (start-trans alg))
         (notes (notes alg))
         (start (start-trans alg))
         (specials (special-notes alg))
         (size (length segments))
         (tp (make-array (list size (+ (* 96 *nmodes*) *nspecials*)) :element-type 'double-float))
         (m (make-array (list size (+ (* 96 *nmodes*) *nspecials*)) :element-type 'integer)))
    (dbg :hmm-prof "Setting up initial conditions...~%")
    (iter (for note from 0 below *nlabels*)
          (setf (aref tp 0 note)
                (+ (probabilities (first segments) notes specials note)
                   (aref start note))))
    (dbg :hmm-prof " ... done.~%")
    (iter (for i from 1 below size)
          (for seg in (cdr segments))
          (dbg :hmm-prof "  Analysing sonority ~a~%" i)
          (iter (for j from 0 below *nlabels*)
                (let ((prob (probabilities seg notes specials j)))
                  (multiple-value-bind (maxjp maxp)
                      (argmax  #L(+ (aref tp (1- i) !1) (get-tran tran strans !1 j)) 0 *nlabels*)
                    (setf (aref tp i j) (+ prob maxp)
                          (aref m i j) maxjp)))))
    (dbg :hmm-prof "Backtracking...~%")
    (let ((chords (list (argmax #L(aref tp (1- size) !1) 0 *nlabels*))))
      (iter (for i from (1- size) downto 1)
            (push (aref m i (first chords)) chords))
      (mapcar #'number->label chords))))

(defmethod perform-analysis (segments options (alg hmm))
  (declare (ignore options))
  (let ((result (add-inversions segments (viterbi-decode segments alg))))
    (dbg :hmm-prof "Done...~%")
    result))

(add-algorithm (make-instance 'hmm
                              :name "EC-Hmm"
                              :description "A Hidden Markov Model for chord labeling."))

(defclass hmm-bayes (hmm) ())

(defun train-hmm-bayes (alg)
  (let* ((pairs (collect-pairs *training-data*))
         (chords (reduce #'append (mapcar #'second *training-data*))))
    (setf (notes alg) (estimate-chord-notes pairs)
          (special-notes alg) (estimate-special-notes pairs)
          (start-trans alg) (estimate-start-trans chords))))

(defmethod do-options ((alg hmm-bayes) options)
  (when (aget :visualize (arg :options options))
    (output-note-images alg))
  (when (aget :train (arg :options options))
    (train-hmm-bayes alg)))

(defun bayes-decode (segments alg)
  (let ((notes (notes alg))
        (specials (special-notes alg))
        (start (start-trans alg)))
    (iter (for s in segments)
          (for n from 0)
          (dbg :hmm-prof " Bayes-Analyzing sonority ~a~%" n)
          (collect (number->label (argmax #L(+ (probabilities s notes specials !1)
                                               (aref start !1))
                                          0
                                          *nlabels*))))))

(defmethod perform-analysis (segments options (alg hmm-bayes))
  (declare (ignore options))
  (add-inversions segments (bayes-decode segments alg)))

(add-algorithm (make-instance 'hmm-bayes
                              :name "ES-Bay"
                              :description "A naive bayes classifier for chord labeling."))