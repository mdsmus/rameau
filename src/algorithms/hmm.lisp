(defpackage :rameau-hmm
  (:import-from #:arnesi "AIF" "IT" "LAST1" "ENABLE-SHARP-L-SYNTAX" "AWHEN")
  (:shadowing-import-from #:rameau-base #:defun #:defmacro #:defparameter #:defvar #:defstruct)
  (:use #:cl #:rameau #:genoslib #:iterate :cl-lily)
  (:documentation "A hidden markov model and a bayesian chord labelers.

A nice discussion of how they work is found in @file{docs/hmm.tex}.
"))

(in-package :rameau-hmm)

(enable-sharp-l-syntax)

;;; Implementação de um algoritmo para análise harmônica automática
;;; usando modelos de Markov escondidos. A descrição do modelo usado
;;; está em docs/hmm.tex.

(declaim (optimize (speed 0)
                   (safety 0)
                   (debug 0)))

(defclass hmm (rameau-algorithm)
  ((transitions :accessor trans :initform nil)
   (special-transitions :accessor special-trans :initform nil)
   (initial-transitions :accessor start-trans :initform nil)
   (chord-notes :accessor notes :initform nil)
   (special-notes :accessor special-notes :initform nil)
   (version :accessor hmm-version :initform 0)))

(defmethod you-ok-p ((alg hmm))
  (and (start-trans alg) (notes alg) (special-notes alg)))

(defparameter *version* 1)

(defparameter *chords*
  (iter (for root from 0 to 95)
        (declare (fixnum root))
        (appending (iter (for mode in '("" "m" "+" "°" "ø" "!"))
                         (appending (iter (for seventh in '("" "7" "7-" "7+"))
                                          (collect (make-chord :root (print-note (code->notename root) :latin)
                                                               :mode mode
                                                               :7th seventh))))))))

(defparameter *modes*
  (iter (for mode in '("" "m" "+" "°" "ø" "!"))
        (appending (iter (for seventh in '("" "7" "7-" "7+"))
                         (collect (make-chord :root "C"
                                              :mode mode
                                              :7th seventh))))))

(defparameter *nct* (list (make-melodic-note)))
(defparameter *aug6s* (iter (for type in '("al" "fr" "it"))
                            (collect (make-augmented-sixth :type type))))

(defparameter *specials* (append *nct* *aug6s*))

(defparameter *labels* (append *chords* *nct* *aug6s*))
(defparameter *nlabels* (length *labels*))
(defparameter *nchords* (length *chords*))
(defparameter *nmodes* (length *modes*))
(defparameter *nspecials* (length *specials*))

(defun mode->list (mode)
  (list :chord (make-keyword (chord-mode mode)) (make-keyword (chord-7th mode))))

(defparameter *lmodes* (mapcar #'mode->list *modes*))

(defun mode->number (mode)
  (position (mode->list mode) *lmodes* :test #'equal))

(defun number->mode (number)
  (nth number *modes*))

(defun label->list (label)
  (cond ((chord-p label)
         (list :chord (make-keyword (chord-mode label)) (make-keyword (chord-root label)) (make-keyword (chord-7th label))))
        ((melodic-note-p label)
         (list :melodic-note))
        ((augmented-sixth-p label)
         (list :augmented-sixth (make-keyword (augmented-sixth-type label))))
        ((null label)
         (error "Should not be nil"))
        ((listp label)
         (label->list (first label)))
        (t (list :other))))

(defparameter *llabels* (mapcar #'label->list *labels*))
(defparameter *lspecials* (mapcar #'label->list *specials*))

(defun label->number (label)
  (or (position (label->list label) *llabels* :test #'equal)
      (error "Should never be nil")))

(defun number->label (number)
  (nth number *labels*))

(defun special->number (label)
  (or (position (label->list label) *lspecials* :test #'equal)
      (error "Should never be nil")))

(defun number->special (number)
  (nth number *specials*))

(defun transpose-96 (data)
  (destructuring-bind (coral gabarito) data
    (iter (for i from 0 to 95)
          (declare (fixnum i))
          (collect (list (transpose-segmentos coral i)
                         (transpose-chords gabarito i))))))

(defun collect-pairs (data)
  (iter (for (chorale answer) in data)
        (nconcing (iter (for c in chorale)
                        (for a in answer)
                        (collect (list c a))))))

(defun reroot (prev chord)
  (if (chord-p chord)
      (make-chord :root (print-note (code->notename (module (- (the fixnum (parse-note (chord-root chord)))
                                                               (the fixnum (parse-note (chord-root prev)))))))
                  :mode (chord-mode chord)
                  :7th (chord-7th chord))
      (if (listp chord)
          (make-melodic-note)
          chord)))

(defun not-zero (value not-zero)
  (if (= 0d0 value)
      (the double-float not-zero)
      (the double-float value)))

(defun dirichlett-smooth (array sizea sizeb)
  (iter (for i from 0 below sizea)
        (declare (fixnum i))
        (let ((sum (iter (for j from 0 below sizeb) (sum (aref array (+ (* sizeb i) j)))))
              (zeros (iter (for j from 0 below sizeb) (counting (= 0 (aref array (+ (* sizeb i) j)))))))
          (iter (for j from 0 below sizeb)
                (setf (aref array (+ (* sizeb i) j))
                      (log (/ (not-zero (aref array (+ (* sizeb i) j)) (/ 1 (+ 0.00000001d0 zeros))) (1+ sum))))))))

(defun estimate-transitions (chords)
  (let ((transitions (make-array (* *nmodes* *nlabels*) :initial-element 0d0 :element-type 'double-float)))
    (iter (for c in chords)
          (for p previous c)
          (when (and p c (chord-p p))
            (incf (aref transitions (+ (* *nlabels* (mode->number p)) (label->number (reroot p c)))))))
    (dirichlett-smooth transitions *nmodes* *nlabels*)
    transitions))

(defun estimate-special-transitions (chords)
  (let ((transitions (make-array (* *nmodes* *nlabels*) :initial-element 0d0 :element-type 'double-float)))
    (iter (for c in chords)
          (for p previous c)
          (when (and p c (not (chord-p p)) (not (listp p)))
            (incf (aref transitions (+ (* *nlabels* (special->number p)) (label->number c))))))
    (dirichlett-smooth transitions *nmodes* *nlabels*)
    transitions))

(defun estimate-chord-notes (pairs)
  (let ((pairs (mapcar #L(and (chord-p (second !1))
                              (list (mode->number (second !1)) (mapcar #'event-pitch (first !1)) (parse-note (chord-root (second !1)))))
                       pairs))
        (probs (make-array (list (* *nmodes* 96)) :initial-element 0d0 :element-type 'double-float)))
    (iter (for (label notes root) in pairs)
          (and label notes root
               (iter (for n in notes)
                     (incf (aref probs (+ (* 96 label) (module (- n root))))))))
    (dirichlett-smooth probs *nmodes* 96)
    probs))

(defun get-special (l)
  (if (listp l)
      (iter (for i in l)
            (unless (chord-p i)
              (return i)))
      l))

(defun estimate-special-notes (pairs)
  (let ((pairs (mapcar #L(and (not (listp (second !1)))
                              (not (chord-p (second !1)))
                              (list (special->number (get-special (second !1))) (mapcar #'event-pitch (first !1))))
                       pairs))
        (probs (make-array (list (* *nspecials* 96)) :initial-element 0d0 :element-type 'double-float)))
    (iter (for (label notes) in pairs)
          (and label notes
               (iter (for n in notes)
                     (incf (aref probs (+ (* 96 label) n))))))
    (dirichlett-smooth probs *nspecials* 96)
    probs))

(defun estimate-start-trans (chords)
  (let ((start (make-array *nlabels* :element-type 'double-float :initial-element 0d0)))
    (iter (for c in chords)
          (if (listp c)
              (iter (for cc in c)
                    (incf (aref start (label->number cc))))
              (incf (aref start (label->number c)))))
    (dirichlett-smooth start 1 *nlabels*)
    start))

(defun train-hmm (alg)
  (let* ((chords (reduce #'append (mapcar #'second *training-data*)))
         (pairs (collect-pairs *training-data*)))
    (setf (trans alg) (estimate-transitions chords)
          (special-trans alg) (estimate-special-transitions chords)
          (special-notes alg) (estimate-special-notes pairs)
          (start-trans alg) (estimate-start-trans chords)
          (notes alg) (estimate-chord-notes pairs))))

(defun output-note-images (alg)
  ;; chord-notes
  (let ((notes (notes alg))
        (specials (special-notes alg)))
    (cl-cairo2:with-png-file
        ((logical-pathname-namestring "rameau:docs;view-hmm-note-probabilities.png")
         'cl-cairo2:format-argb32
         900
         1050)
      (cl-cairo2:rectangle 0 0 900 1050)
      (cl-cairo2:set-source-rgb 1 1 1)
      (cl-cairo2:fill-path)
      (cl-cairo2:set-source-rgb 0 0 0)
      (cl-cairo2:select-font-face "Vera" 'cl-cairo2:font-slant-normal 'cl-cairo2:font-weight-normal)
      (cl-cairo2:set-font-size 10)
      (dbg :hmm-prof "Putting the notenames~%")
      (iter (for i from 0 to 95)
            (cl-cairo2:move-to 5  (+ 5 (* i 10)))
            (cl-cairo2:show-text (print-note (code->notename i))))
      (dbg :hmm-prof "Putting the chords~%")
      (iter (for i from 0)
            (for chord in *modes*)
            (cl-cairo2:move-to (+ 60 (* 30 i)) 1000)
            (cl-cairo2:show-text (format nil "~s" chord)))
      (iter (for i from *nmodes*)
            (for chord in *specials*)
            (cl-cairo2:move-to (+ 60 (* 30 i)) 1000)
            (cl-cairo2:show-text (format nil "~s" chord)))
      (cl-cairo2:set-source-rgb 1 0 0)
      (dbg :hmm-prof "Counting the colors~%")
      (let ((max most-negative-double-float)
            (min most-positive-double-float))
        (iter (for i from 0 below *nmodes*)
              (iter (for j from 0 below 96)
                    (when (< max (aref notes (+ (* 96 i) j)))
                      (setf max (aref notes (+ (* 96 i) j))))
                    (when (> min (aref notes (+ (* 96 i) j)))
                      (setf min (aref notes (+ (* 96 i) j))))))
        (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%" min max)
        (iter (for i from 0 below *nmodes*)
              (for n from 0)
              (iter (for j from 0 below 96)
                    (cl-cairo2:rectangle (+ 70 (* 30 n))
                                         (* 10 j)
                                         (normalize 0d0 4d0 min max (aref notes (+ (* 96 i) j)))
                                         (normalize 0d0 4d0 min max (aref notes (+ (* 96 i) j))))
                    (cl-cairo2:fill-path))
              (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*))
        (dbg :hmm-prof "Now the special chords.~%")
        (iter (for i from (- *nlabels* *nspecials*) below *nlabels*)
              (for n from 0)
              (for m from *nmodes*)
              (iter (for j from 0 below 96)
                    (cl-cairo2:rectangle (+ 70 (* 30 m))
                                         (* 10 j)
                                         (normalize 0d0 4d0 min max (aref specials (+ (* 96 n) j)))
                                         (normalize 0d0 4d0 min max (aref specials (+ (* 96 n) j))))
                    (cl-cairo2:fill-path))
              (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*))))))

(defun output-transition-images (alg)
  (let ((tr (trans alg))
        (str (special-trans alg)))
    (cl-cairo2:with-png-file
        ((logical-pathname-namestring "rameau:docs;view-hmm-trans-probabilities.png")
         'cl-cairo2:format-argb32
         8000
         500)
      (cl-cairo2:rectangle 0 0 10000 600)
      (cl-cairo2:set-source-rgb 1 1 1)
      (cl-cairo2:fill-path)
      (cl-cairo2:set-source-rgb 0 0 0)
      (cl-cairo2:select-font-face "Vera" 'cl-cairo2:font-slant-normal 'cl-cairo2:font-weight-normal)
      (cl-cairo2:set-font-size 10)
      (dbg :hmm-prof "Putting the input labels~%")
      (iter (for i from 0)
            (for c in *modes*)
            (cl-cairo2:move-to 0 (+ 50 (* i 10)))
            (cl-cairo2:show-text (format nil "~a" c)))
      (iter (for i from *nmodes*)
            (for c in *specials*)
            (cl-cairo2:move-to 0 (+ 50 (* i 10)))
            (cl-cairo2:show-text (format nil "~a" c)))
      (dbg :hmm-prof "Putting the output labels~%")
      (iter (for i from 0)
            (for c in *labels*)
            (cl-cairo2:move-to (+ 40 (* 3 i)) (+ 410 (mod (* 10 i) 100)))
            (cl-cairo2:show-text (format nil "~a" c)))
      (dbg :hmm-prof "Finding the minimal and maximal weights~%")
      (cl-cairo2:set-source-rgb 1 0 0)
      (let ((max most-negative-double-float)
            (min most-positive-double-float))
        (iter (for i from 0 below *nmodes*)
              (iter (for j from 0 below *nlabels*)
                    (when (< max (aref tr (+ (* *nlabels* i) j)))
                      (setf max (aref tr (+ (* *nlabels* i) j))))
                    (when (> min (aref tr (+ (* *nlabels* i) j)))
                      (setf min (aref tr (+ (* *nlabels* i) j))))))
        (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%"
             min max)
        (iter (for i from 0 below *nmodes*)
              (iter (for j from 0 below *nlabels*)
                    (cl-cairo2:rectangle (+ 40 (* 3 j))
                                         (+ 50 (* 10 i))
                                         (normalize 0d0 4d0 min max (aref tr (+ (* *nlabels* i) j)))
                                         (normalize 0d0 4d0 min max (aref tr (+ (* *nlabels* i) j))))
                    (cl-cairo2:fill-path))
              (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*))
        (iter (for n from *nmodes* below (+ *nmodes* *nspecials*))
              (for i from 0)
              (iter (for j from 0 below *nlabels*)
                    (cl-cairo2:rectangle (+ 40 (* 3 j))
                                         (+ 50 (* 10 n))
                                         (normalize 0d0 4d0 min max (aref str (+ (* *nlabels* i) j)))
                                         (normalize 0d0 4d0 min max (aref str (+ (* *nlabels* i) j))))
                    (cl-cairo2:fill-path))
              (dbg :hmm-prof "One more line --- ~a of ~a ~%" i *nlabels*))))))

(defun output-prior-images (alg)
  (let ((tr (start-trans alg)))
    (cl-cairo2:with-png-file
        ((logical-pathname-namestring "rameau:docs;view-hmm-prior-probabilities.png")
         'cl-cairo2:format-argb32
         100
         23080)
      (cl-cairo2:rectangle 0 0 110 23080)
      (cl-cairo2:set-source-rgb 1 1 1)
      (cl-cairo2:fill-path)
      (cl-cairo2:set-source-rgb 0 0 0)
      (cl-cairo2:select-font-face "Vera" 'cl-cairo2:font-slant-normal 'cl-cairo2:font-weight-normal)
      (cl-cairo2:set-font-size 10)
      (dbg :hmm-prof "Putting the output labels~%")
      (iter (for i from 0)
            (for c in *labels*)
            (cl-cairo2:move-to 10 (+ 5 (* 10 i)))
            (cl-cairo2:show-text (format nil "~a" c)))
      (dbg :hmm-prof "Finding the minimal and maximal weights~%")
      (cl-cairo2:set-source-rgb 1 0 0)
      (let ((max most-negative-double-float)
            (min most-positive-double-float))
        (iter (for i from 0 below *nlabels*)
              (iter (for j from 0 below *nlabels*)
                    (when (< max (aref tr i))
                      (setf max (aref tr i)))
                    (when (> min (aref tr i))
                      (setf min (aref tr i)))))
        (dbg :hmm-prof "Min:~a Max:~a~% Drawing the probabilities..;~%"  min max)
        (iter (for i from 0 below *nlabels*)
              (cl-cairo2:rectangle 70
                                   (+ 7 (* 10 i))
                                   (normalize 0d0 4d0 min max (aref tr i))
                                   (normalize 0d0 4d0 min max (aref tr i)))
              (cl-cairo2:fill-path))))))

;; (setf my-hmm (last1 rameau:*algorithms*))
;;(output-transition-images my-hmm)
;; (train-hmm my-hmm)

(defmethod do-options ((alg hmm) options)
  (when (aget :visualize (arg :options options))
    (output-prior-images alg)
    (output-note-images alg)
    (output-transition-images alg)
    )
  (when (and (aget :train (arg :options options))
             (not (eql *version* (hmm-version alg))))
    (format t "Training hmm...~%")
    (train-hmm alg)
    (setf (hmm-version alg) *version*)))

(defun notes-probabilities (segment notes i j)
  (let ((pitches (mapcar #'event-pitch segment)))
    (iter (for p in pitches)
          (declare (fixnum p))
          (sum (aref notes (+ (* 96 i) (module (- p j))))))))

(defun special-probabilities (segment specials special)
  (let ((pitches (mapcar #'event-pitch segment)))
    (iter (for p in pitches)
          (declare (fixnum p))
          (sum (aref specials (+ (* 96 special) p))))))

(defparameter *maxmodes* (* 96 *nmodes*))

(defun probabilities (seg notes specials j)
  (declare (fixnum j *maxmodes* *nmodes*))
  (if (< j *maxmodes*)
      (notes-probabilities seg notes (mod j *nmodes*) (truncate j *nmodes*))
      (special-probabilities seg specials (- j *maxmodes*))))

(defun get-tran (tr str p c)
  (declare (fixnum p c *maxmodes* *nmodes* *nlabels*)
           ((array double-float) tr str))
  (if (< p *maxmodes*)
      (let* ((m (mod p *nmodes*))
             (rr2 (+ (* (module (- (truncate c *nmodes*)
                                   (truncate p *nmodes*)))
                        *nmodes*)
                     (mod c *nmodes*))))
        (aref tr (+ (* *nlabels* m)
                    rr2)))
      (aref str (+ (* *nlabels* (- p *maxmodes*))
                   c))))

(defun viterbi-decode (segments alg)
  (let* ((tran (trans alg))
         (strans (special-trans  alg))
                                        ;(ini (start-trans alg))
         (notes (notes alg))
         (start (start-trans alg))
         (specials (special-notes alg))
         (size (length segments))
         (cache nil)
         (tp (make-array (list size (+ (* 96 *nmodes*) *nspecials*)) :element-type 'double-float))
         (m (make-array (list size (+ (* 96 *nmodes*) *nspecials*)) :element-type 'integer)))
    (dbg :hmm-prof "Setting up initial conditions...~%")
    (iter (for note from 0 below *nlabels*)
          (declare (fixnum note))
          (setf (aref tp 0 note)
                (+ (probabilities (first segments) notes specials note)
                   (aref start note)))
          (setf cache (clip 10 (insert (list (aref tp 0 note) (aref m 0 note) 0 note) cache :less #'> :key #'first))))
    (dbg :hmm-prof " ... done.~%")
    (iter (for i from 1 below size)
          (declare (fixnum i))
          (for seg in (cdr segments))
          (dbg :hmm-prof "  Analysing sonority ~a~%" i)
          (for newcache = nil)
          (iter (for j from 0 below *nlabels*)
                (let* ((prob (probabilities seg notes specials j))
                       (values (iter (for (vtp vm previ prevj) in cache)
                                     (finding (list (+ (aref tp (1- i) prevj)
                                                       (get-tran tran strans prevj j))
                                                    prevj)
                                              maximizing (+ (aref tp (1- i) prevj)
                                                            (get-tran tran strans prevj j))))))
                  (setf (aref tp i j) (+ (* 2 prob) (first values))
                        (aref m i j) (second values))
                  (setf newcache (clip 10 (insert (list (aref tp i j) (aref m i j) i j) newcache :less #'> :key #'first)))))
          (setf cache newcache)
          (dbg :hmm-prof "Cache is: ~a~%" (mapcar2 #'number->label #'fourth cache)))
    (dbg :hmm-prof "Backtracking...~%")
    (let ((chords (list (argmax #L(aref tp (1- (the fixnum size)) !1) 0 *nlabels*))))
      (iter (for i from (1- size) downto 1)
            (push (aref m i (first chords)) chords))
      (mapcar #'number->label chords))))

(defmethod perform-analysis (segments options (alg hmm))
  (declare (ignore options))
  (let ((result (add-inversions segments (viterbi-decode segments alg))))
    (dbg :hmm-prof "Done...~%")
    result))

(add-algorithm (make-instance 'hmm
                              :name "EC-Hmm"
                              :description "A Hidden Markov Model for chord labeling."))

(defclass hmm-bayes (hmm) ())

(defun train-hmm-bayes (alg)
  (let* ((pairs (collect-pairs *training-data*))
         (chords (reduce #'append (mapcar #'second *training-data*))))
    (setf (notes alg) (estimate-chord-notes pairs)
          (special-notes alg) (estimate-special-notes pairs)
          (start-trans alg) (estimate-start-trans chords))))

(defmethod do-options ((alg hmm-bayes) options)
  (when (aget :visualize (arg :options options))
    (output-note-images alg))
  (when (and (aget :train (arg :options options))
             (not (eql *version* (hmm-version alg))))
    (format t "Training bayes...~%")
    (train-hmm-bayes alg)
    (setf (hmm-version alg) *version*)))

(defun bayes-decode (segments alg)
  (let ((notes (notes alg))
        (specials (special-notes alg))
        (start (start-trans alg)))
    (iter (for s in segments)
          (for n from 0)
          (dbg :hmm-prof " Bayes-Analyzing sonority ~a~%" n)
          (collect (number->label (argmax #L(+ (probabilities s notes specials !1)
                                               (aref start !1))
                                          0
                                          *nlabels*))))))

(defmethod perform-analysis (segments options (alg hmm-bayes))
  (declare (ignore options))
  (add-inversions segments (bayes-decode segments alg)))

(add-algorithm (make-instance 'hmm-bayes
                              :name "ES-Bay"
                              :description "A naive bayes classifier for chord labeling."))